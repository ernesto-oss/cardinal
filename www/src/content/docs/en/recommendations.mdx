---
title: "Recommendations"
description: "Some steps you can take in order to decide how you want to setup your stack."
---

import Detail from "@/components/docs/mdx/detail.tsx";
import DeepDive from "@/components/docs/mdx/deep-dive.tsx";

Cardinal gives you many choices for how to setup your stack. Choosing between frontend frameworks, backend types and deployment paths can be daunting, but we can help you by giving you some tips on how to get the best out of Cardinal for optimal development experience.

## Choose a single deployment provider for your entire stack

Whenever possible, stick to a single deployment provider for both your frontend and backend services, specially when using Next.js, which already gives you access to the backend layer right within the framework with features like **[API Routes]()** and **[Middlewares]()**. Dividing your deployment between several deployment providers will have you dealing with more complexity on both the application and the infrastructure layer.

Cardinal encourages this behavior by configuring your entire application to work with the choosen deployment provider.

<DeepDive client:load title="How Cardinal sets up deployment paths?">
    When you choose a deployment provider for your Cardinal project, we setup default configurations for all parts of
    your app based on that deployment provider. If you chose Next.js as your frontend framework, you will also be
    presented with the option of running your backend service directly from Next.js

    When hosted on **[Vercel]()** we will simply give you instructions on how to deploy directly from GitHub, or from
    the **[Vercel CLI]()**.

    When hosted on **[AWS]()**, we will setup all your infrastructure with **[SST]()**, a framework built on top of AWS's CDK, that
    makes serverless setups on top of AWS stupidly simple. It will take care of provisioning all the required services to run your application.

</DeepDive>

## Choose the backend type that makes sense for your project

Cardinal gives you three options for setting up your API service: **REST**, **GraphQL**, and **tRPC**.

### tRPC

tRPC is a RPC (**[Remote Procedure Call]()**) framework. Semantically speaking, this means **a client requesting functionality from somewhere remote**. The idea behind this concept is that you think in terms of commands, as oposed to REST, where you usually think in terms of resources.

tRPC has become an increasingly popular way of building API's with TypeScript because of it's unmatched capacity of achieving end-to-end typesafety between server and client when both are written in TypeScript.

Much like with GraphQL, the client will provide you with a typesafe way of querying resources from the server, with the main key difference here being that the types are infered directly from the server code, which makes the feedback loop instant.

**Pros:**

- Really good option for use cases where you have functionality on your app that can be declared as commands.
- End-to-end typesafety between client and server without relying on codegen.

**Cons:**

- Quickly looses value once it's used outside of TypeScript (you just lost client type-safety, and you're left with a REST API).

<Detail type="note">
  While technically tRPC requests are going via HTTP to a REST endpoint, that is not the part about the tRPC
  implementation that matters. You're not going to interact with that endpoint directly, the tRPC client will do that
  for you, and that is where most of it's value resides.
</Detail>

### GraphQL

GraphQL is a well stabilished, altough slightly complex way of building API's. It really shines when you're dealing with complex data relations within a graph, and the client applications needs to be really aware of those connections.

With GraphQL, both client and server share knowledge about the schema, and that schema defines the shape of how data is queried and returned from your server.

**Pros:**

- Graph based data modeling allows for easier representation of complex data relations.
- Query language allows fine grained control of what is requested from the server.
- Has robust and well-maintained client implementations for other languages outside of TypeScript.

**Cons:**

- Server has more moving pieces and overall added complexity.
- Client type generation is still dependent on codegen (there are projects working on trying to make this better for TypeScript).

<DeepDive client:load title="How does type generation differ between GraphQL and tRPC?">
    On GraphQL, client types are generated by analying the server schema, and transforming the types of that schema into something that TypeScript can understand. For that to happen, a process needs to run, a new type definitions need to be created on a file before they can be used on the client.

    With tRPC, the client implementation infers the types directly from code written in server context, which means they are reflected in the entire app in real time.

</DeepDive>

## Choose a database type that makes sense for your project

There are too many database options out there. Hopefully, ORM's like Prisma, for the most part, don't care about your underlying database, it will just talk to what you throw at it.

Because of this, we don't really prescribe what you use for your database layer within Cardinal. But we can give you some pointers.

If you want something simple and self-managed, **[PlanetScale]()** is a no-brainer. You don't think about manually handling scaling, connection distribution or backups, it just does it. For most projects, it should be a good option.

If you're building your project on top of AWS, you can **[use your existing SST configuration to deploy self-managed Amazon RDS instances]()**.

Outside of that, you can feel free to use whatever **[Prisma supports connecting to]()**. Compare different database types and their features, and figure out what makes more sense for your application.

---
title: "Why Cardinal?"
description: "Why should you use Cardinal when there are so many other starter solutions out there."
---

import Detail from "@/components/docs/mdx/detail.tsx";
import Components from "@/components/docs/mdx/components.tsx";
export const components = Components;

With the recent shift to serverless focused technologies and end-to-end typesafety between client and server becoming a larger priority on developers minds, there has been more and more tools at our disposal. Putting them together for each new project takes some time and effort. We wanted to give you that time back so you can start building applications faster.

This is a relatively opinionated project. It has to be in order to do what it was built to do. Maybe it doesn't fit your needs, and that's fine.

If what you see here seems to fit your project needs, give it a try, and If it doesn't you can move on to something else. We won't be mad.

## Is this a template?

By definition, we could define it as a multi-template scaffolding CLI tool, but that's just a matter of semantics. The choices you make during the CLI prompts ultimately define how your project will be scaffolded in the end.

## Why is this tech included?

The decision behind what libraries/frameworks goes into each part of the scaffolded project is not taken lightly. In order to be considered, it has to meet a few criterias:

- It needs to be TypeScript friendly and have well-typed API's and primitives;
- It has to be mature enough to handle production workloads without breaking;
- It should interact well with serverless architectures and their runtimes;

### TypeScript

If we really think about it. TypeScript is the glue that holds everything together. It's because of it that we can ensure end-to-end typesafety between server and client. It helps you have a better time developing JavaScript applications, and, at this point, it is an industry standard to developing safe web applications.

Templates scaffolded by Cardinal will always be configured with TypeScript by default.

### Authentication modules

Modern and **secure** authentication and authorization is hard. Try implementing it by yourself, and suddenly you will have to deal with several implementation choices, manual integration with OAuth providers, and proper implementation of security protocols. It's a lot.

We firmly believe that most new project authors should not be trying to roll out their own implementation of authentication and authorization features. The surface area for introducing critical security issues to your applications increases massively unless you really know what you're doing.

Cardinal offers you some choices in that regard. When applicable, you will be offered ways of self-hosting your authentication module within your application with options like **[NextAuth](https://next-auth.js.org/)** or **[SSTAuth](https://docs.sst.dev/constructs/Auth)**. Both are serverless friendly and stateless options with passwordless authentication flows by default.

In cases where there is no viable self-hosted solution for your stack, or if you want to entirely outsource the authentication to a dedicated third-party, we also offer to pre-configure **[Clerk](https://clerk.com/)**, a user management SaaS with a very generous free-tier and fair pricing.

<Detail type="note">
  NextAuth is currently in the process of becoming **Auth.js**. The key difference is that instead of being an
  authentication solution only for Next.js apps, it's going to have a framework agnostic core with custom
  implementations for each framework (Next.js, SvelteKit, SolidStart). When stable releases become available for all of
  these implementations, Auth.js will become the standard authentication library in Cardinal, with SST Auth as an
  optional second exclusively for AWS deployments.
</Detail>

### Database ORM

**[Prisma](https://www.prisma.io/)** is currently the only ORM for the TypeScript ecosystem that is cabable of:

- Automatically generating types from a user-defined schema with `prisma generate`.
- Automatically setup database tables from a user-defined schema `prisma push`.
- Providing simultaneous compatibility with several database types.
- Oferring tools for database visualization and management.

This is why it's still the most sensible option to provide a typesafe layer between your server logic and your database.

<Detail type="note">
  While Prisma still has incomparable developer experience, it's **[heavy toll on serverless functions has been under a
  lot of discussion lately](https://www.youtube.com/watch?v=3tl9XCiQErA)**. Cardinal is actively looking at more
  serverless oriented and lightweight solutions currently emerging on the ORM space, like
  **[Drizzle](https://github.com/drizzle-team/drizzle-orm)** for future releases.
</Detail>

### Backend tools

Depending on what you choose as your frontend framework and deployment path, we will setup different tooling that will compose your `api` module.

In cases were you opt to choose for full-stack frameworks like Next.js to build your frontend, the CLI prompt will recommend serving your API directly from the framework, but will also give your the option to configure and run it as a standalone service on a different cloud provider if you so prefer.

Any backend type you choose will be also integrated with Prisma and the chosen authentication module when applicable.

import { prisma } from "@acme/database";
import { builder } from "../builder";

builder.prismaNode("Post", {
  id: { field: "id" },
  fields: (t) => ({
    title: t.exposeString("title"),
    content: t.expose("content", {
      type: "Json",
      nullable: true,
    }),
    createdAt: t.expose("createdAt", {
      type: "DateTime",
    }),
    updatedAt: t.expose("updatedAt", {
      type: "DateTime",
    }),
    published: t.exposeBoolean("published"),
    author: t.relation("author"),
    authorId: t.exposeString("authorId"),
  }),
});

const CreatePostInput = builder.inputType("CreatePostInput", {
  fields: (t) => ({
    title: t.string({
      description: "Title of the created post",
      required: true,
    }),
    content: t.field({
      description:
        "Content of the created post in JSON format, as generated by editor.js",
      type: "Json",
      required: false,
    }),
    published: t.boolean({
      description: "Determines if the post should be marked as a draft",
      required: true,
    }),
  }),
});

const UpdatePostInput = builder.inputType("UpdatePostInput", {
  fields: (t) => ({
    id: t.string({ description: "ID of the post to update", required: true }),
    title: t.string({
      description: "Title of the post to update",
      required: false,
    }),
    content: t.field({
      description:
        "Content of the post to update, in JSON format, as generated by editor.js. Note that all the previous data is overwritten by an update",
      type: "Json",
      required: false,
    }),
    published: t.boolean({
      description: "Determines if the post should be marked as a draft",
      required: true,
    }),
  }),
});

const DeletePostInput = builder.inputType("DeletePostInput", {
  fields: (t) => ({
    id: t.string({ description: "ID of the post to delete", required: true }),
  }),
});

builder.mutationFields((t) => ({
  createPost: t.prismaField({
    description: "Creates an post on the currently authenticated user",
    authScopes: {
      authorizedUser: true,
    },
    type: "Post",
    nullable: false,
    args: {
      input: t.arg({ type: CreatePostInput, required: true }),
    },
    resolve: async (query, _root, { input }, ctx) => {
      const authorId = ctx.session?.user?.id as string;

      const post = await prisma.post.create({
        ...query,
        data: {
          title: input.title,
          content: input.content || "",
          published: input.published,
          authorId: authorId,
        },
      });

      if (!post)
        throw new Error(
          "The post could not be created. Check if the provided input is correct.",
        );

      return post;
    },
  }),
  updatePost: t.prismaField({
    description:
      "Updates an existing post on the currently authenticated user. This mutation will only update posts from the currently authenticated user, and fail otherwise",
    authScopes: {
      authorizedUser: true,
    },
    type: "Post",
    nullable: false,
    args: {
      input: t.arg({ type: UpdatePostInput, required: true }),
    },
    resolve: async (query, _root, { input }, ctx) => {
      const postToUpdate = await prisma.post.findFirst({
        where: {
          id: input.id,
          authorId: ctx.session?.user?.id as string,
        },
        select: {
          id: true,
        },
      });

      if (!postToUpdate) {
        throw new Error(
          "The post could not be found, or you do not have the correct permissions to update it",
        );
      }

      const post = await prisma.post.update({
        ...query,
        where: { id: postToUpdate.id },
        data: {
          title: input.title || undefined,
          content: input.content || undefined,
          published: input.published,
        },
      });

      return post;
    },
  }),
  deletePost: t.prismaField({
    description:
      "Deletes an existing post on the currently authenticated user. This mutation will only delete posts from the currently authenticated user, and fail otherwise",
    authScopes: {
      authorizedUser: true,
    },
    type: "Post",
    nullable: true,
    args: {
      input: t.arg({ type: DeletePostInput, required: true }),
    },
    resolve: (query, _root, { input }) => {
      const post = prisma.post.delete({
        ...query,
        where: { id: input.id },
      });

      return post;
    },
  }),
}));

builder.queryFields((t) => ({
  postById: t.prismaField({
    description: "Gets a single post that matches the provided ID. This query will only return posts that are owned by the currently authenticated user, and fail otherwise",
    authScopes: {
      authorizedUser: true,
    },
    type: "Post",
    nullable: true,
    args: {
      id: t.arg.id({ required: true, description: "The ID of the post" }),
    },
    resolve: async (query, _root, args, ctx) => {
      const postId = args.id as string;

      const post = await prisma.post.findFirst({
        ...query,
        where: {
          id: postId,
          authorId: ctx.session?.user?.id as string,
        },
      });

      if (post) {
        throw new Error(
          "The post could not be found. or you do not have the correct permissions to view it",
        );
      }

      return post;
    },
  }),
  postsByUser: t.prismaConnection({
    description: "Gets all posts for a currently authenticated user",
    authScopes: {
      authorizedUser: true,
    },
    type: "Post",
    nullable: true,
    cursor: "id",
    resolve: async (query, _root, _args, ctx) => {
      const id = ctx.session?.user?.id as string;

      const user = await prisma.post.findMany({
        ...query,
        where: { authorId: id },
      });

      if (!user) return null;

      return user;
    },
  }),
}));
